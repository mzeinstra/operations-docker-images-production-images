#!/usr/bin/env python3
import argparse
import os

from contextlib import contextmanager

import docker
import docker.errors
import yaml

from jinja2 import Environment, FileSystemLoader, Template
from debian.changelog import Changelog

known_images = {}


@contextmanager
def pushd(dirname):
    cur_dir = os.getcwd()
    os.chdir(dirname)
    yield
    os.chdir(cur_dir)


def find_image_tag(image_name):
    if image_name not in known_images:
        print('WARNING: image {name} not found'.format(name=image_name))
        return ""
    image = known_images[image_name]
    return "{}:{}".format(image.name, image.tag)


def apt_installer(opts):
    t = Template("""
{%- if http_proxy -%}
RUN echo 'Acquire::http::Proxy \"{{ http_proxy }}\";' > /etc/apt/apt.conf.d/80_proxy \\
    && apt-get update {{ apt_options }} \\
{%- else -%}
RUN apt-get update {{ apt_options }} \\
{%- endif %}
    && DEBIAN_FRONTEND=noninteractive \\
    apt-get install {{ apt_options }} --yes {{ packages }} --no-install-recommends \\
{%- if http_proxy %}
    && rm -f /etc/apt/apt.conf.d/80_proxy \\
{%- endif %}
    && apt-get clean && rm -rf /var/lib/apt/lists/* """)

    def apt_install(pkgs):
        return t.render(**opts, packages=pkgs)
    return apt_install


class DockerImage(object):

    def __init__(self, path, config):
        self.path = path
        env = Environment(loader=FileSystemLoader(path))
        env.filters['image_tag'] = find_image_tag
        env.filters['apt_install'] = apt_installer(config)
        self.tpl = env.get_template('Dockerfile.template')
        self.config = config
        with open(os.path.join(path, 'changelog'), 'rb') as fh:
            chlog = fh.read()
        changelog = Changelog(chlog)
        self.tag = str(changelog.get_version())
        self.name = str(changelog.get_package())

    def apt_installer(self):
        env = Environment()

    @property
    def dockerfile(self):
        dockerfile = self.tpl.render(**self.config)
        print('Generated Dockerfile:')
        print('===')
        print(dockerfile)
        print('===')
        return dockerfile


class DockerBuilder(object):

    def __init__(self, directory, configfile):
        self.base_directory = os.path.join(os.getcwd(), directory)
        self.config = {
            'registry': 'docker-registry.wikimedia.org',
            'username': None, 'password': None,
            'seed_image': 'wikimedia-stretch:latest',
            'apt_options': '',
            'http_proxy': None,
        }
        self.config.update(self._read_config(configfile))
        self.client = docker.from_env(version='auto')

    def _read_config(self, configfile):
        with open(configfile, 'rb') as fh:
            raw_config = yaml.load(fh)
        return {k: v for k, v in raw_config.items()
                if k in self.config}

    def scan(self):
        """
        Scan the base directory for image definitions, and create the
        corresponding dockerfile
        """
        for root, dirs, files in os.walk(self.base_directory):
            if 'Dockerfile.template' in files:
                print(
                    'Processing the dockerfile template in {base}'.format(base=root)
                )
                yield DockerImage(root, self.config)

    def image_exists(self, image):
        try:
            self.client.images.get("{}:{}".format(image.name, image.tag))
            return True
        except docker.errors.ImageNotFound:
            return False

    def build(self, image):
        print('Building image {name}:{version}'.format(name=image.name, version=image.tag))
        print('Build context: {path}'.format(path=image.path))
        image_ref = "{name}:{tag}".format(name=image.name, tag=image.tag)
        with pushd(image.path):
            with open('Dockerfile', 'w') as fh:
                fh.write(image.dockerfile)
            self.client.images.build(
                path='.',
                tag=image_ref,
                nocache=True,
                rm=True,
                pull=False,
            )
            os.remove('Dockerfile')
        print("Image built.")
        fullname = os.path.join(self.config['registry'], image.name)
        for tag in [image.tag, 'latest']:
            self.client.api.tag(image_ref, fullname, tag)
            yield (fullname, tag)

    def publish(self, name, tag):
        """Publish the locally built image to the registry"""
        if all([self.config['username'], self.config['password']]):
            self.client.login(
                self.config['username'],
                password=self.config['password'],
                registry=self.config['registry']
            )
            command_output = self.client.api.push(name, tag)
            print(command_output)
        else:
            print('Not pushing as credentials are not set.')


def main(args):
    db = DockerBuilder(args.directory, args.configfile)
    for image in db.scan():
        if db.image_exists(image):
            continue
        for name, tag in db.build(image):
            known_images[image.name] = image
            db.publish(name, tag)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', '--configfile', default="config.yaml")
    parser.add_argument('directory')
    return parser.parse_args()


if __name__ == '__main__':
    main(parse_args())
