#!/usr/bin/env python3
import argparse
import os
import tarfile

from contextlib import contextmanager
from io import BytesIO

import docker
import docker.errors
import yaml

from jinja2 import Environment, FileSystemLoader, Template
from jinja2.exceptions import TemplateNotFound
from debian.changelog import Changelog

known_images = {}


@contextmanager
def pushd(dirname):
    cur_dir = os.getcwd()
    os.chdir(dirname)
    yield
    os.chdir(cur_dir)


def find_image_tag(image_name):
    if image_name not in known_images:
        print('WARNING: image {name} not found'.format(name=image_name))
        return ""
    image = known_images[image_name]
    return str(image)


def apt_installer(opts):
    t = Template("""
{%- if http_proxy -%}
RUN echo 'Acquire::http::Proxy \"{{ http_proxy }}\";' > /etc/apt/apt.conf.d/80_proxy \\
    && apt-get update {{ apt_options }} \\
{%- else -%}
RUN apt-get update {{ apt_options }} \\
{%- endif %}
    && DEBIAN_FRONTEND=noninteractive \\
    apt-get install {{ apt_options }} --yes {{ packages }} --no-install-recommends \\
{%- if http_proxy %}
    && rm -f /etc/apt/apt.conf.d/80_proxy \\
{%- endif %}
    && apt-get clean && rm -rf /var/lib/apt/lists/* """)

    def apt_install(pkgs):
        return t.render(packages=pkgs, **opts)
    return apt_install


def apt_pruner(opts):
    t = Template("""
{%- if http_proxy -%}
echo 'Acquire::http::Proxy \"{{ http_proxy }}\";' > /etc/apt/apt.conf.d/80_proxy  && \\
{%- endif -%}
    apt update && DEBIAN_FRONTEND=noninteractive apt-get remove --yes --purge --autoremove {{ packages }} \\
{%- if http_proxy %}
    && rm -f /etc/apt/apt.conf.d/80_proxy \\
{%- endif %}
    && apt-get clean && rm -rf /var/lib/apt/lists/* """)

    def apt_prune(pkgs):
        return t.render(packages=pkgs, **opts)
    return apt_prune


class DockerImage(object):

    def __init__(self, path, config):
        self.path = path
        self.env = Environment(loader=FileSystemLoader(path))
        self.env.filters['image_tag'] = find_image_tag
        self.env.filters['apt_install'] = apt_installer(config)
        self.env.filters['apt_prune'] = apt_pruner(config)
        self.config = config
        with open(os.path.join(path, 'changelog'), 'rb') as fh:
            chlog = fh.read()
        changelog = Changelog(chlog)
        self.tag = str(changelog.get_version())
        self.name = str(changelog.get_package())
        self.build_tag = '{name}-build:{tag}'.format(name=self.name,
                                                     tag=self.tag)

    def exists(self, client):
        """
        Checks existence of a docker image
        """
        try:
            client.images.get(str(self))
            return True
        except docker.errors.ImageNotFound:
            return False

    @property
    def dockerfile(self):
        tpl = self.env.get_template('Dockerfile.template')
        dockerfile = tpl.render(**self.config)
        return dockerfile

    @property
    def dockerfile_build(self):
        try:
            tpl = self.env.get_template('Dockerfile.build.template')
        except TemplateNotFound:
            return None
        return tpl.render(**self.config)

    def build(self, client, build_container=False):
        """
        Build the image.
        Parameters:
          client - a docker.client instance
          build_container - if True, this will build the build container for
              the image. If False (the default), it will build the actual image.

        Returns: the tag for the image built, or None if no dockerfile was found,
                 False if an exception was raised.
        """
        filename = os.path.join(self.path, 'Dockerfile')
        tag = str(self)

        if build_container:
            filename += '.build'
            tag = self.build_tag
            dockerfile = self.dockerfile_build
        else:
            dockerfile = self.dockerfile

        if dockerfile is None:
            return None
        with open(filename, 'w') as fh:
            fh.write(dockerfile)

        print('===')
        print('Generated dockerfile for image {img}:'.format(img=tag))
        print(dockerfile)
        print('===')
        try:
            client.images.build(
                path=self.path,
                dockerfile=filename,
                tag=tag,
                nocache=True,
                rm=True,
                pull=False,
            )
            return tag
        except Exception as e:
            print("Building image {} failed: {}".format(tag, e))
            return False

    def __str__(self):
        return "{}:{}".format(self.name, self.tag)


class DockerBuilder(object):

    def __init__(self, directory, configfile):
        self.base_directory = os.path.join(os.getcwd(), directory)
        self.config = {
            'registry': 'docker-registry.wikimedia.org',
            'username': None, 'password': None,
            'seed_image': 'wikimedia-stretch:latest',
            'apt_options': '',
            'http_proxy': None,
        }
        self.config.update(self._read_config(configfile))
        self.client = docker.from_env(version='auto', timeout=600)

    def _read_config(self, configfile):
        with open(configfile, 'rb') as fh:
            raw_config = yaml.load(fh)
        return {k: v for k, v in raw_config.items()
                if k in self.config}

    def scan(self):
        """
        Scan the base directory for image definitions, and create the
        corresponding dockerfile
        """
        for root, dirs, files in os.walk(self.base_directory):
            if 'Dockerfile.template' in files:
                print(
                    '* Processing the dockerfile template in {base}'.format(
                        base=root)
                )
                yield DockerImage(root, self.config)

    def _build_artifacts(self, image):
        print('==> Building artifacts')
        print('===> Creating the build image')
        image_tag = image.build(self.client, build_container=True)
        if image_tag is None:
            return True
        elif image_tag is False:
            print('*** ERROR: Building artifacts failed!')
            os.remove('Dockerfile.build')
            return False
        else:
            os.remove('Dockerfile.build')

        print('==> Extracting artifacts from the build image')

        try:
            container = self.client.containers.create(
                image_tag,
                name="{}-build_ephemeral".format(image.name),
                network_disabled=False,
            )
            archive = container.get_archive('/build')
        except Exception as e:
            print(
                '*** ERROR: creating the build container failed: {}'.format(e))
            self.client.images.remove(image_tag)
            return False

        print('==> Write artifacts to the filesystem')
        try:
            tar = tarfile.open(mode="r", fileobj=BytesIO(archive[0].data))
            tar.extractall()
            container.remove()
            self.client.images.remove(image_tag)
            return True
        except Exception as e:
            print('*** ERROR: Tar extraction failed: {}'.format(e))
            container.remove()
            self.client.images.remove(image_tag)
            return False

    def build(self, image):
        print('=> Building image {name}:{version}'.format(
            name=image.name, version=image.tag))
        print('* Build context: {path}'.format(path=image.path))
        with pushd(image.path):
            if self._build_artifacts(image) is False:
                return
            print('==> Building the image')
            img_name = image.build(self.client)
            os.remove('Dockerfile')
        if img_name is False:
            print('** ERROR: Image {} NOT built!'.format(image))
            return
        fullname = os.path.join(self.config['registry'], image.name)
        for tag in [image.tag, 'latest']:
            self.client.api.tag(str(image), fullname, tag)
            yield (fullname, tag)

    def publish(self, name, tag):
        """Publish the locally built image to the registry"""
        if all([self.config['username'], self.config['password']]):
            self.client.login(
                self.config['username'],
                password=self.config['password'],
                registry=self.config['registry']
            )
            command_output = self.client.api.push(name, tag)
            print(command_output)
        else:
            print('Not pushing as credentials are not set.')


def main(args):
    db = DockerBuilder(args.directory, args.configfile)
    print("> Scanning {}".format(db.base_directory))
    for image in db.scan():
        known_images[image.name] = image
        if image.exists(db.client):
            continue
        for name, tag in db.build(image):
            db.publish(name, tag)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', '--configfile', default="config.yaml")
    parser.add_argument('directory')
    return parser.parse_args()


if __name__ == '__main__':
    main(parse_args())
